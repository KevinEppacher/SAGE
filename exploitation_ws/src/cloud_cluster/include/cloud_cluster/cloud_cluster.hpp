#ifndef CLOUDCLUSTER_H
#define CLOUDCLUSTER_H

#include <rclcpp/rclcpp.hpp>
#include <sensor_msgs/msg/point_cloud2.hpp>
#include <pcl_conversions/pcl_conversions.h>
#include <pcl/point_types.h>
#include <pcl/segmentation/extract_clusters.h>
#include <pcl/search/kdtree.h>
#include <pcl/common/common.h>
#include <visualization_msgs/msg/marker_array.hpp>
#include <vector>
#include "cloud_cluster/graph_node_collection.hpp"
#include <chrono>
#include <algorithm>
#include <cmath>  // for std::log

class CloudCluster : public rclcpp::Node {
    public:
        CloudCluster();
        ~CloudCluster();

    private:
        // Subscribers
        rclcpp::Subscription<sensor_msgs::msg::PointCloud2>::SharedPtr semanticPointcloudSub;
        rclcpp::node_interfaces::OnSetParametersCallbackHandle::SharedPtr paramCallbackHandle;
        void semanticCloudCallback(const sensor_msgs::msg::PointCloud2::SharedPtr msg);
        rcl_interfaces::msg::SetParametersResult onParameterChange(const std::vector<rclcpp::Parameter> &params);

        // Publishers
        rclcpp::Publisher<visualization_msgs::msg::MarkerArray>::SharedPtr markerPub;

        // Timers
        rclcpp::TimerBase::SharedPtr timer;
        void timerCallback();

        // Miscalleneous functions
        geometry_msgs::msg::Point getCentroid(pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud);
        double getScoreCluster(pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud);
        void configureEuclideanClusterExtraction();
        void publishBoundingBoxes(const std::vector<pcl::PointIndices>& clusters, pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud);
        void getParameters();

        pcl::PointCloud<pcl::PointXYZRGB>::Ptr semanticPointcloud;
        double publishFrequency;
        double clusterTolerance;
        int minClusterSize;
        int maxClusterSize;
        double voxelLeafSize;


    std::shared_ptr<GraphNodeCollection> graphNodes;
};
    
#endif // CLOUDCLUSTER_H
