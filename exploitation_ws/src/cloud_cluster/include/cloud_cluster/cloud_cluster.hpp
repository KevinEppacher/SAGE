#ifndef CLOUDCLUSTER_H
#define CLOUDCLUSTER_H

#include <rclcpp/rclcpp.hpp>
#include <sensor_msgs/msg/point_cloud2.hpp>
#include <pcl_conversions/pcl_conversions.h>
#include <pcl/point_types.h>
#include <pcl/segmentation/extract_clusters.h>
#include <pcl/search/kdtree.h>
#include <pcl/common/common.h>
#include <visualization_msgs/msg/marker_array.hpp>
#include "cloud_cluster/graph_node.hpp"
#include <vector>

class CloudCluster : public rclcpp::Node {
    public:
        CloudCluster();
        ~CloudCluster();

    private:
        // Subscribers
        rclcpp::Subscription<sensor_msgs::msg::PointCloud2>::SharedPtr semanticPointcloudSub;
        void semanticCloudCallback(const sensor_msgs::msg::PointCloud2::SharedPtr msg);

        // Publishers
        rclcpp::Publisher<visualization_msgs::msg::MarkerArray>::SharedPtr markerPub;

        // Timers
        rclcpp::TimerBase::SharedPtr timer;
        void timerCallback();

        // Miscalleneous functions
        geometry_msgs::msg::Point getCentroid(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud);
        void configureEuclideanClusterExtraction();
        void publishBoundingBoxes(const std::vector<pcl::PointIndices>& clusters, pcl::PointCloud<pcl::PointXYZ>::Ptr cloud);
    
        std::vector<GraphNode> graphNodes;
        pcl::PointCloud<pcl::PointXYZ>::Ptr semanticPointcloud;
        // KD-Tree for Clustering
        std::vector<pcl::PointIndices> clusterIndices;
        pcl::EuclideanClusterExtraction<pcl::PointXYZ> ec;

};
    
#endif // CLOUDCLUSTER_H
