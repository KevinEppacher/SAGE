#include <rclcpp/rclcpp.hpp>
#include <sensor_msgs/msg/point_cloud2.hpp>
#include <pcl_conversions/pcl_conversions.h>
#include <pcl/point_types.h>
#include <pcl/segmentation/extract_clusters.h>
#include <pcl/search/kdtree.h>
#include <visualization_msgs/msg/marker_array.hpp>

class ClusterNode : public rclcpp::Node {
public:
    ClusterNode() : Node("cluster_node") {
        sub_ = this->create_subscription<sensor_msgs::msg::PointCloud2>(
            "/openfusion/semantic_pointcloud", 10,
            std::bind(&ClusterNode::cloud_callback, this, std::placeholders::_1));
        pub_ = this->create_publisher<visualization_msgs::msg::MarkerArray>("/clusters", 10);
    }

private:
    void cloud_callback(const sensor_msgs::msg::PointCloud2::SharedPtr msg) {
        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>());
        pcl::fromROSMsg(*msg, *cloud);

        pcl::search::KdTree<pcl::PointXYZ>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZ>());
        tree->setInputCloud(cloud);

        std::vector<pcl::PointIndices> cluster_indices;
        pcl::EuclideanClusterExtraction<pcl::PointXYZ> ec;
        ec.setClusterTolerance(0.15); // 15cm
        ec.setMinClusterSize(50);
        ec.setMaxClusterSize(10000);
        ec.setSearchMethod(tree);
        ec.setInputCloud(cloud);
        ec.extract(cluster_indices);

        visualization_msgs::msg::MarkerArray markers;
        int id = 0;
        for (const auto& indices : cluster_indices) {
            // Compute Axis-Aligned Bounding Box (AABB)
            float min_x = std::numeric_limits<float>::max();
            float min_y = std::numeric_limits<float>::max();
            float min_z = std::numeric_limits<float>::max();
            float max_x = std::numeric_limits<float>::lowest();
            float max_y = std::numeric_limits<float>::lowest();
            float max_z = std::numeric_limits<float>::lowest();

            for (int idx : indices.indices) {
                const auto& pt = cloud->points[idx];
                if (!std::isfinite(pt.x) || !std::isfinite(pt.y) || !std::isfinite(pt.z)) continue;
                min_x = std::min(min_x, pt.x);
                min_y = std::min(min_y, pt.y);
                min_z = std::min(min_z, pt.z);
                max_x = std::max(max_x, pt.x);
                max_y = std::max(max_y, pt.y);
                max_z = std::max(max_z, pt.z);
            }

            float center_x = (min_x + max_x) / 2.0;
            float center_y = (min_y + max_y) / 2.0;
            float center_z = (min_z + max_z) / 2.0;

            float size_x = (max_x - min_x);
            float size_y = (max_y - min_y);
            float size_z = (max_z - min_z);

            visualization_msgs::msg::Marker m;
            m.header.frame_id = msg->header.frame_id;
            m.header.stamp = msg->header.stamp;
            m.ns = "bbox";
            m.id = id++;
            m.type = visualization_msgs::msg::Marker::CUBE;
            m.action = visualization_msgs::msg::Marker::ADD;
            m.pose.position.x = center_x;
            m.pose.position.y = center_y;
            m.pose.position.z = center_z;
            m.pose.orientation.w = 1.0;
            m.scale.x = size_x;
            m.scale.y = size_y;
            m.scale.z = size_z;
            m.color.r = 0.0f;
            m.color.g = 1.0f;
            m.color.b = 0.0f;
            m.color.a = 0.5f;  // halbtransparent

            markers.markers.push_back(m);
        }

    pub_->publish(markers);
}
    rclcpp::Subscription<sensor_msgs::msg::PointCloud2>::SharedPtr sub_;
    rclcpp::Publisher<visualization_msgs::msg::MarkerArray>::SharedPtr pub_;
};

int main(int argc, char ** argv)
{
  rclcpp::init(argc, argv);
  auto node = std::make_shared<ClusterNode>();
  rclcpp::spin(node);
  rclcpp::shutdown();
  return 0;
}
