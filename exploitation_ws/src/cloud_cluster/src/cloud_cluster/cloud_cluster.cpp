#include "cloud_cluster.hpp"

CloudCluster::CloudCluster() : Node("cluster_node") 
{
    RCLCPP_INFO(this->get_logger(), "CloudCluster Node started");

    // Define subscribers
    semanticPointcloudSub = this->create_subscription<sensor_msgs::msg::PointCloud2>(
        "/openfusion/semantic_pointcloud", 10,
        std::bind(&CloudCluster::semanticCloudCallback, this, std::placeholders::_1)
    );

    // Define publishers
    markerPub = this->create_publisher<visualization_msgs::msg::MarkerArray>(
        "cloud_cluster/bounding_boxes", 10
    );
    

    // Define timers
    // timer = this->create_wall_timer(
    //     std::chrono::milliseconds(500),
    //     std::bind(&CloudCluster::timerCallback, this)
    // );

    // Initialize the point cloud
    semanticPointcloud = pcl::PointCloud<pcl::PointXYZ>::Ptr(new pcl::PointCloud<pcl::PointXYZ>());

    configureEuclideanClusterExtraction();

}

CloudCluster::~CloudCluster() 
{
    RCLCPP_INFO(this->get_logger(), "CloudCluster Node stopped");
}

void CloudCluster::semanticCloudCallback(const sensor_msgs::msg::PointCloud2::SharedPtr msg)
{
    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>());
    pcl::fromROSMsg(*msg, *cloud);

    pcl::search::KdTree<pcl::PointXYZ>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZ>());
    tree->setInputCloud(cloud);

    std::vector<pcl::PointIndices> cluster_indices;
    pcl::EuclideanClusterExtraction<pcl::PointXYZ> ec;
    ec.setClusterTolerance(0.15); // 15cm
    ec.setMinClusterSize(50);
    ec.setMaxClusterSize(10000);
    ec.setSearchMethod(tree);
    ec.setInputCloud(cloud);
    ec.extract(cluster_indices);

    visualization_msgs::msg::MarkerArray markers;
    int id = 0;
    for (const auto& indices : cluster_indices) 
    {
        // Compute Axis-Aligned Bounding Box (AABB)
        float min_x = std::numeric_limits<float>::max();
        float min_y = std::numeric_limits<float>::max();
        float min_z = std::numeric_limits<float>::max();
        float max_x = std::numeric_limits<float>::lowest();
        float max_y = std::numeric_limits<float>::lowest();
        float max_z = std::numeric_limits<float>::lowest();

        for (int idx : indices.indices) 
        {
            const auto& pt = cloud->points[idx];
            if (!std::isfinite(pt.x) || !std::isfinite(pt.y) || !std::isfinite(pt.z)) continue;
            min_x = std::min(min_x, pt.x);
            min_y = std::min(min_y, pt.y);
            min_z = std::min(min_z, pt.z);
            max_x = std::max(max_x, pt.x);
            max_y = std::max(max_y, pt.y);
            max_z = std::max(max_z, pt.z);
        }

        float center_x = (min_x + max_x) / 2.0;
        float center_y = (min_y + max_y) / 2.0;
        float center_z = (min_z + max_z) / 2.0;

        float size_x = (max_x - min_x);
        float size_y = (max_y - min_y);
        float size_z = (max_z - min_z);

        visualization_msgs::msg::Marker m;
        m.header.frame_id = msg->header.frame_id;
        m.header.stamp = msg->header.stamp;
        m.ns = "bbox";
        m.id = id++;
        m.type = visualization_msgs::msg::Marker::CUBE;
        m.action = visualization_msgs::msg::Marker::ADD;
        m.pose.position.x = center_x;
        m.pose.position.y = center_y;
        m.pose.position.z = center_z;
        m.pose.orientation.w = 1.0;
        m.scale.x = size_x;
        m.scale.y = size_y;
        m.scale.z = size_z;
        m.color.r = 0.0f;
        m.color.g = 1.0f;
        m.color.b = 0.0f;
        m.color.a = 0.5f;  // halbtransparent

        markers.markers.push_back(m);

    }

    markerPub->publish(markers);
}

geometry_msgs::msg::Point CloudCluster::getCentroid(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud)
{
    geometry_msgs::msg::Point centroid;
    if (cloud->empty()) return centroid;

    double x = 0, y = 0, z = 0;
    for (const auto& pt : cloud->points) 
    {
        x += pt.x;
        y += pt.y;
        z += pt.z;
    }

    size_t n = cloud->points.size();
    centroid.x = x / n;
    centroid.y = y / n;
    centroid.z = z / n;

    return centroid;
}

void CloudCluster::configureEuclideanClusterExtraction()
{
    ec.setClusterTolerance(0.15);    // Abstand in Metern
    ec.setMinClusterSize(50);       // Mindestanzahl Punkte pro Cluster
    ec.setMaxClusterSize(10000);    // Maximalanzahl Punkte pro Cluster

    RCLCPP_INFO(this->get_logger(), "Euclidean Cluster Extraction configured");
    RCLCPP_INFO(this->get_logger(), "Cluster Tolerance: %f", ec.getClusterTolerance());
    RCLCPP_INFO(this->get_logger(), "Min Cluster Size: %d", ec.getMinClusterSize());
    RCLCPP_INFO(this->get_logger(), "Max Cluster Size: %d", ec.getMaxClusterSize());
}

void CloudCluster::publishBoundingBoxes(const std::vector<pcl::PointIndices>& clusters, pcl::PointCloud<pcl::PointXYZ>::Ptr cloud)
{
    visualization_msgs::msg::MarkerArray marker_array;
    int id = 0;

    for (const auto& indices : clusters)
    {
        pcl::PointCloud<pcl::PointXYZ>::Ptr cluster(new pcl::PointCloud<pcl::PointXYZ>());
        for (int idx : indices.indices)
        {
            const auto& pt = cloud->points[idx];
            if (!std::isfinite(pt.x) || !std::isfinite(pt.y) || !std::isfinite(pt.z)) continue;
            cluster->points.push_back(pt);
        }

        // Skip empty clusters
        if (cluster->points.empty()) continue;

        // Bounding Box berechnen auf cluster
        float min_x = std::numeric_limits<float>::max();
        float min_y = std::numeric_limits<float>::max();
        float min_z = std::numeric_limits<float>::max();
        float max_x = std::numeric_limits<float>::lowest();
        float max_y = std::numeric_limits<float>::lowest();
        float max_z = std::numeric_limits<float>::lowest();

        for (const auto& pt : cluster->points)
        {
            if (!std::isfinite(pt.x) || !std::isfinite(pt.y) || !std::isfinite(pt.z)) continue;

            min_x = std::min(min_x, pt.x);
            min_y = std::min(min_y, pt.y);
            min_z = std::min(min_z, pt.z);
            max_x = std::max(max_x, pt.x);
            max_y = std::max(max_y, pt.y);
            max_z = std::max(max_z, pt.z);
        }

        float center_x = (min_x + max_x) / 2.0;
        float center_y = (min_y + max_y) / 2.0;
        float center_z = (min_z + max_z) / 2.0;

        float size_x = std::max(0.01f, max_x - min_x);
        float size_y = std::max(0.01f, max_y - min_y);
        float size_z = std::max(0.01f, max_z - min_z);

        visualization_msgs::msg::Marker box;
        box.header.frame_id = "map";
        box.header.stamp = this->get_clock()->now();
        box.ns = "cloud_cluster/bbox";
        box.id = id++;
        box.type = visualization_msgs::msg::Marker::CUBE;
        box.action = visualization_msgs::msg::Marker::ADD;

        box.pose.position.x = center_x;
        box.pose.position.y = center_y;
        box.pose.position.z = center_z;
        box.pose.orientation.w = 1.0;

        box.scale.x = size_x;
        box.scale.y = size_y;
        box.scale.z = size_z;

        box.color.r = 0.0f;
        box.color.g = 1.0f;
        box.color.b = 0.0f;
        box.color.a = 0.3f;

        // box.lifetime = rclcpp::Duration::from_seconds(0.5);

        marker_array.markers.push_back(box);
    }

    markerPub->publish(marker_array);
}

// void CloudCluster::timerCallback()
// {
//     pcl::PointCloud<pcl::PointXYZ>::Ptr semPcl;
//     semPcl = semanticPointcloud;
//     if (semPcl->empty()) 
//     {
//         RCLCPP_WARN(this->get_logger(), "No pointcloud data to cluster.");
//         return;
//     }

//     // KD-Tree f√ºr Clustering
//     pcl::search::KdTree<pcl::PointXYZ>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZ>());
//     tree->setInputCloud(semPcl);
//     ec.setSearchMethod(tree);
//     ec.setInputCloud(semPcl);
//     ec.extract(clusterIndices);
//     publishBoundingBoxes(clusterIndices, semPcl);

//     // reset graph nodes
//     graphNodes.clear();

//     // Iterate clusters 
//     int cluster_id = 0;
//     for (const auto& indices : clusterIndices)
//     {
//         pcl::PointCloud<pcl::PointXYZ>::Ptr cluster(new pcl::PointCloud<pcl::PointXYZ>());
//         for (int index : indices.indices)
//         {
//             cluster->points.push_back(semPcl->points[index]);
//         }

//         geometry_msgs::msg::Point centroid = getCentroid(cluster);
//         RCLCPP_INFO(this->get_logger(), "Cluster %d centroid: (%f, %f, %f)", cluster_id, centroid.x, centroid.y, centroid.z);

//         GraphNode node;
//         node.setPosition(centroid);
//         graphNodes.push_back(node);

//         cluster_id++;
//     }
    
// }

